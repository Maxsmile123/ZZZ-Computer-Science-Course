# Целые числа и системы счисления

В этой задаче научимся использовать целые числа правильно.

## Знаковый и беззнаковый тип
По стандарту современных процессоров, числа представлены в дополнительном коде.
Крайний слева бит отвечает за знак: 0, если число положительное и 1 если отрицательное.

Так выглядит классический `int`. Диапазон возможных значений в таком случае: $$[-2^{31},2^{31} - 1]$$
> Размер int зависит от архитектуры процессора, о чём написано ниже. По умолчанию информация соответсвует процессорам на архитектуре Intel x86-64.

Имеется также `unsigned int`, в котором знаковый бит трактуется как обычный. Диапазон значений в таком случае выглядит так: $$[0,2^{32} - 1]$$ Это неплохой способ сказать программисту, что значение переменной не будет отрицательным.   

*Не стоит экономить на спичках и везде писать unsigned, чтобы получить бОльший диапазон значений. Это может мешать оптимизациям компилятора, из-за чего код будет работать медленее.*

## Переполнения
Что будет, если выполнить этот код?
```c
unsigned int a = 0;
--a;
printf("%d", a);
```
Или этот:
```c
int a = pow(2, 30); // pow - возведение в степень. 2^30
a = a * 2 + 1;
printf("%d", a);
```

Согласно стандарту языка, такие ситуации называются [Undefined behavior - UB](https://en.wikipedia.org/wiki/Undefined_behavior).   

Это означает, что поведение неопределенно и пользователь не должен расчитывать на какой-либо однозначный результат. Отлавливать такое очень сложно :(

- Если интересно, зачем UB существует в С/C++, посмотрите [доклад](https://www.youtube.com/watch?v=B9iR13VyP-c&t=13133s) на эту тему.

## Считаем байтики
### `Зависимость от архитектуры процессора`
Из популярных архитектур процессоров выделяют следующие:
- Intel x86
- Intel x86-64
- ARM 
- PowerPC

В Intel x86 размер регистра 32 бита = 4 байта.  
В Intel x86-64 размер регистра 64 бита = 8 байт.

`В Intel x86`:
- int - 16 бит
- long int - 32 бита

`В Intel x86-64`:
- int - 32 бит
- long int - 64 бита

## Явно всегда лучше, чем неявно

Чтобы код выполнялся одинаково на всех архитектурах, существуют [специальные типы](https://en.cppreference.com/w/c/types/integer), чётко определяющие размер переменных:
```c
#include <stdint.h>
int64_t a;
int32_t b;
uint64_t c;
```
Именно ими мы и будем оперировать дальше, отказываясь от стандартных **int**, **long long int**, **unsigned int**.

- Существует также специальный тип [`size_t`](http://en.wikipedia.org/wiki/Size_t), которым обозначают размеры. Представляет из себя беззнаковое целое число с максимальным для данной машины размером.

## Позиционные системы счисления

- Для [тех](https://ru.wikipedia.org/wiki/Позиционная_система_счисления), кто в танке.

Нам интересны всего две: бинарная и шестнадцатиричная.

[Бинарная СС](https://ru.wikipedia.org/wiki/Двоичная_система_счисления) оказалось очень удачной в тандеме с транзистором: 0 - тока нет, 1 - ток есть. И булева алгебра, применяемой на схемах.

Поэтому компьютеры и работают с бинарными числами. Существовали эксперименты с компьютерами на троичной системе счисления, но они не прижились.

Однако хранить числа в бинарной СС невыгодно - слова слишком длинные. Числа в памяти лежат в 16-ой = 
[Hexadecimal(Hex)](https://www.techtarget.com/whatis/definition/hexadecimal). Любое целое число можно распечатать или задать, используя hex:
```c
int32_t k = 0xFF // 0x - означает, что это Hex число. В 10-ой(Octal) это 255.
printf("%d\n", k) // Напечатает 255
printf("%x\n", k) // Напечатает ff
```

## Задание

Вам необходимо решить задачу вашего варианта. Свой вариант можно найти [тут](variants.md).

## Важные требования к решению
Чтобы получить максимальный балл за задачу, необходимо удовлетворять следующим критериям:
- Запрещается работать с числом как со строкой.
- Запрещается использовать массивы.
- Нет ограничений на входные данные.
- Код должен быть понятным, названия переменных отражают то, что они хранят.

