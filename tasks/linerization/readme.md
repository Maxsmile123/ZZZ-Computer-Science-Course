# Линеризация матриц


В этой задаче познакомимся с массивами и указателями - самыми важными элементами языков С/C++.

## Массивы
Это отдельный тип данных, который представляет собой последовательность однородных элементов, расположенных в памяти последовательно.

## Указатели
Это число, которое указывает на место в памяти. Адрес этот виртуальный, к физической памяти отношения не имеет.
- [Прочитайте](https://www.baeldung.com/cs/virtual-memory-why) про виртуальную память в ОС.

Указатель является отдельным типом, который обозначается как: ```type*```. *type* нам нужен, чтобы понимать, как интерпретировать данные, которые лежат по данному адресу.

## Массив - это указатель?
Нет. Это предмет вечных споров. С массивом почти всегда взаимодействуют через указатель, потому что массив - это последовательность данных в памяти, а указатель - адрес памяти. 

## Array to pointer conversion
По [стандарту языка](http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf) определена такая операция как *array to pointer conversion*. Почти всегда при взаимодействии с массивом происходит его преобразование в указатель. 
Давайте к примерам:
```c
int a[10];
int* b = a;
printf("%d", a[0] == *b) // Выведет 1, т.е. да, равны
```

## Представление матриц в Си

В классическом понимании матрица - это двумерный массив. Для итерирования по матрице используют две переменные - i, j
(названия пришли к нам из линейной алгебры).

В коде их использование будет выглядеть так:
```c
int matrix[10][12];

for (int i = 0; i < 10; ++i){
    for (int j = 0; j < 12; ++j){
        printf("%d ", matrix[i][j]);
    }
    printf('\n');
} // Печать матрицы
```

В многих источниках иногда пишут плохой код. Там делают так:
```c
size_t n, m;
scanf("%ld%ld", &n, &m);
int matrix[n][m];
```
Некоторые говорят, что это допустимо компилятором gcc и не против такого использования. Давайте просто посмотрим в стандарт языка С11:
_Variable length arrays are a conditional feature that implementations need not support_
> Почитать можно [тут](http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf), страница 130.

Это означает, что компилятор не обязан поддерживать эту функцию. Некоторые компиляторы эти массивы не поддерживают и на то есть причины.

## Виды памяти
Вся сила языков С/С++ в том, что мы можем самостоятельно выбрать вид памяти, где разместить наши данные. Давайте выделим три вида:
- Стек
- Куча
- Файл

Файл относится к памяти хардовой, не оперативной. Загружать файлы в оперативную память, к слову, плохая идея и является уязвимостью.

Про кучу. Куча представляет собой ~всю оперативную память. Т.е. она ограниченна физически вашей оперативкой, которая в современных ноутбуках минимум 4ГБ. 
> Про устройство кучи подробно рассказано на занятии. 

А стек представляет собой ограниченный блок памяти на 8МБ, в который кладутся все локальные переменные и их копии, вызовы функций.

## Массивы с переменным размером
8МБ против 8ГБ кучи... Поэтому и не любят рекурсию - она каждым вызовом сохраняет на стек адрес возрата(8 байт) и все локальные переменные, все параметры. Аналогично может произойти с массивами, объявленным так: 
```c
size_t n, m;
scanf("%ld%ld", &n, &m);
int matrix[n][m];
```
Это уязвимость, которую можно эксплуатировать и ложить целые сервера. Что будет, если пользователь введёт 
```
n = 18446744073709551615
m = 18446744073709551615 // это максимальное значение uint64_t. 
```
Страшно.
Давайте даже возьмём максимальные значения типа int: </br>
```2 147 483 647 = 2^32 - 1```</br>
А потом возьмём в руки калькулятор и посчитаем:</br> 
```2^32 * 2^32 * 2^2 (sizeof(int)) = 2^28 ТБ```</br>
Да, даже оперативка не вся справиться :)

Переполнить стек намного проще, чем кучу. Поэтому любые данные переменной длины нужно располагать на куче. При помощи операций *malloc/calloc*:
```c
size_t n, m;
scanf("%ld%ld", &n, &m);
int** matrix = (int**)malloc(sizeof(int*) * n);
for (size_t i = 0; i < n; ++i){
    matrix[i] = (int**)malloc(sizeof(int*) * m);
}
```
Выглядит стрёмно, но это единственно правильный способ. Если Вы знаете размер матрицы на этапе компиляции (до запуска программы), то смело аллоцируйте массив на стеке.

### Для каждого выделения памяти требуется своё освобождение памяти!
Иначе говоря, не забывайте освобождать память после того, как она вам больше не нужна:
```c
for (size_t i = 0; i < n; ++i){
    free(matrix[i]);

free(matrix);
```
Если не освободить, будет [утечка памяти](https://en.wikipedia.org/wiki/Memory_leak).
> В С++ принята [идеома RAII](https://en.cppreference.com/w/cpp/language/raii), которая защищает программиста от забывания освободить ресурсы.

- Прочитайте про [malloc](https://en.cppreference.com/w/c/memory/malloc)
- Прочитайте про [calloc](https://en.cppreference.com/w/c/memory/calloc)
- Прочитайте про [realloc](https://en.cppreference.com/w/c/memory/realloc)
- Прочитайте про [free](https://en.cppreference.com/w/c/memory/free)


## Задание

Вам необходимо решить задачу вашего варианта. Свой вариант можно найти [тут](variants.md).

## Важные требования к решению
Чтобы получить максимальный балл за задачу, необходимо удовлетворять следующим критериям:
- Используются динамические выделения памяти
- Код должен быть понятным, названия переменных отражают то, что они хранят.
- Нет ограничений на размеры матрицы

Не выполнение любого из этих условий может служить поводом для снижения итогового балла. Или не может, если Вы умеете грамотно защищать свою точку зрения :=)

## Предостережение

Если Вы не присутствовали на занятии или просто там уснули - посмотрите эти лекции: [тык](https://www.youtube.com/watch?v=njfH8PHghWo&list=PLoNf82n__sV4_evodYxUhNIQIliCvGXyl&index=14&t=1s) и [тык](https://www.youtube.com/watch?v=rJUd7YKRFXc&list=PLoNf82n__sV4_evodYxUhNIQIliCvGXyl&index=15). Тема большая и важная, всё в этом документе освещать нецелесообразно. 


